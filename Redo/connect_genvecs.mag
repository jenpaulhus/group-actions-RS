/* This program connects generating vectors of monodromy groups to the
      corresponding generators on the abstract groups pages, connects
      conjugacy class vectors to the corresponding labels on the abstract
      groups pages, and uses a new labeling convention for total_label and 
      passport_label. 
   Data of the form total_label|passport_label|con|con_label|connected_genvec
      is printed to a txt file.
*/

/* Set the variable gxx below to the desired genus and also replace gxx in
      the string for the input file. */
gxx:=6;

/* Input file */
load "SupplementaryFiles/BreuerRaw/g06";



if gxx lt 10 then
   genus_str := "0" cat IntegerToString(gxx);
else
   genus_str := IntegerToString(gxx);
end if;


/* Output file */
output_file := Sprintf("g%o_connected_genvecs.txt", genus_str);

output_str := "total_label|passport_label|con|con_label|connected_genvec" cat
              "\ntext|text|text|text|jsonb\n\n";


/* load gps_decode, a list (generated by a Python script) containing
      data from the groups db needed to construct groups in magma */
load "gps_decode.mag";

/* load RepresentativesEpimorphisms  */
load "genvectors.mag";

/* load PermRep */
load "ries_helper_fn.mag";

/* for ordercc function */
Attach("orderCC.m");

/* dependencies of orderCC.m */
Attach("mb-gp-elts.m");
Attach("random.m");



/* Create associative array of groups data, indexed by gp_label, for
      quick accessing */
db_data := AssociativeArray();
for gp in gps_decode do
   gp_label := gp[1];
   db_data[gp_label] := [* gp[2], gp[3], gp[4], gp[5], gp[6] *];
end for;



/* Regex patterns for magma generators */
base_regex := "\\G.(-?[0-9]+)";
power_regex := "\\^(-?[0-9]+)";

/* This function takes in a generator from a generating vector of a solvable
      group and returns it written in terms of letters from the abstract 
      groups page, along with a version of it to be used in sorting.
   G_to_pc is used to rewrite inverse elements as elements raised
      to positive powers for the purpose of sorting.
*/
process_gen := function(gen, G, G_to_pc)

   gen_str := Sprintf("%o", gen);
   parts := Split(gen_str, " * ");

   /* When iterating through parts, processed_gen and to_sort_gen are built
         backwards so that evaluating from right to left gives the correct 
         permutation */
   processed_gen := "";
   to_sort_gen := "";

   for p in parts do
      /* p has one of the following forms: G.i, G.i^j, Id(G) */
      if p eq "Id(G)" then
         processed_gen := processed_gen cat "Id(G)";
         to_sort_gen := to_sort_gen cat "Id(G)";
      else
         is_match, base_match, match_seq := Regexp(base_regex, p);
         i := match_seq[1];
         /* 1 -> a, 2 -> b, and so on */
         letter := CodeToString(StringToInteger(i)+96);
         if base_match eq p then
            /* p has the form G.i */
            processed_gen := letter cat processed_gen;
            to_sort_gen := letter cat to_sort_gen;
         else
            /* p has the form G.i^j */
            remaining := Substring(p, #base_match+1, #p);
            is_match, match, match_seq := Regexp(power_regex, remaining);
            j := StringToInteger(match_seq[1]);
            processed_gen := Sprintf("%o^%o", letter, j) cat processed_gen;
            if j ge 2 then
               for k in [1..j] do
                  to_sort_gen := letter cat to_sort_gen;
               end for;
            else /* j is negative */
               /* The isomorphism G_to_pc maps G.i of the FP group G to the
                     corresponding element in the PC group so that we can use
                     the Order function */
               fp_ele := eval base_match;
               pc_ele := G_to_pc(fp_ele);
               order := Order(pc_ele);
               power := order + j;
               for k in [1..power] do
                  to_sort_gen := letter cat to_sort_gen;
               end for;
            end if;
         end if;
      end if;
   end for;

   return processed_gen, to_sort_gen;

end function;



/* This procedure sorts records from RepresentativesEpimorphisms
      by conjugacy class label vectors and replaces recs[i]`Con
      with index, label pairs. */
sort_recs_by_cc_label := procedure(~recs, group)
   cc := ConjugacyClasses(group);
   cm := ClassMap(group);
   pm := PowerMap(group);
   gens := Generators(group);
   reps, finalkeys, cc_labels := ordercc(group, cc, cm, pm, gens);

   /* Create associative array of conjugacy class label and sorting info,
         indexed by conjugacy class representative */
   A := AssociativeArray();
   for i in [1..#reps] do
      A[reps[i]] := [* cc_labels[i], finalkeys[i] *];
   end for;

   /* Create to_sort, a list corresponding to conjugacy class label vectors
         containing info on how to sort them */
   to_sort := [];
   for i in [1..#recs] do
      Con := recs[i]`Con;
      Con_pairs := [];
      sort_info := [];
      for i in Con do
	 cc_rep := cc[i][3];
         Append(~Con_pairs, [* i, A[cc_rep][1] *]);
         Append(~sort_info, A[cc_rep][2]);
      end for;
      /* Replace recs[i]`Con with a list of index, label pairs */
      recs[i]`Con := Con_pairs;
      Append(~to_sort, sort_info);
   end for;

   /* Sort to_sort lexicographically, performing the corresponding sort
         in recs */
   ParallelSort(~to_sort, ~recs);

end procedure;



/* Regex pattern for group generators on abstract groups pages */
group_gen_regex := "([a-z])(\\^-?[0-9]+)?";



/* This function is a helper function for compare_genvecs_s (unused) to
      determine the ordering of the connected generating vectors.
   gen1 and gen2 are elements of two different vectors, but they are
   at the same position in the two vectors (which have the same length). 

   Id(G) takes precedence, then the alphabetical order of the first letter is
      considered, then the power of the first letter 
      (power = 1 takes precedence), and if everything
      is the same up until this point, the next letter is considered. 
   Ex: Id(G) < a < ab < abc < ab^2 < a^-1b < a^2 < a^2b < b 
*/
compare_gens := function(gen1, gen2)

   /* gen1, gen2 might be Id(G) */
   is_match1 := gen1 eq "Id(G)";
   is_match2 := gen2 eq "Id(G)";
   if is_match1 and not is_match2 then
      return -1;
   elif is_match1 and is_match2 then
      return 0;
   elif not is_match1 and is_match2 then
      return 1;
   /* else, both gen1 and gen2 are not Id(G) */
   end if;

   remaining1 := gen1;
   remaining2 := gen2;
   while remaining1 ne "" and remaining2 ne "" do
      /* Continue comparing gen1 and gen2 */
      is_match1, match1, match_seq1 := Regexp(group_gen_regex, remaining1);
      is_match2, match2, match_seq2 := Regexp(group_gen_regex, remaining2);
      letter1 := match_seq1[1];
      letter2 := match_seq2[1];
      /* Order by alphabetical order of letters */
      ordering := StringToCode(letter1) - StringToCode(letter2);
      if ordering ne 0 then
         return ordering;
      end if;
      /* The letters are the same, so order by the power */
      /* If a letter is to the first power, then #match_seq eq 1.
         Otherwise, #match_seq eq 2. */
      ordering := #match_seq1 - #match_seq2;
      if ordering ne 0 then
         return ordering;
      end if;
      /* Either both are to the first power or both are not */
      if #match_seq1 eq 2 then
         /* Both have a power not equal to 1, so order by that power treated
               as an integer */
         power1 := StringToInteger(Substring(match_seq1[2], 2, #match_seq1[2]));
         power2 := StringToInteger(Substring(match_seq2[2], 2, #match_seq2[2]));
         ordering := power1 - power2;
         if ordering ne 0 then
            return ordering;
         end if;
      end if;
      /* The letters and powers are the same, so start the process over 
            with the next letter */
      if match1 eq remaining1 then
         /* There is no next letter */
         remaining1 := "";
      else 
         /* Set remaining1 to the next sequence of letters */
         remaining1 := Substring(remaining1, #match1+1, #remaining1);
      end if;
      if match2 eq remaining2 then
         remaining2 := "";
      else
         remaining2 := Substring(remaining2, #match2+1, #remaining2);
      end if;
   end while;
   /* At least one of remaining1, remaining2 is the empty string */
   ordering := #remaining1 - #remaining2;
   return ordering;
end function;

/* Unused function

   This function is a comparison function to be used in sorting lists of
      connected generating vectors lexicographically for solvable groups.
   It determines how genvec1 and genvec2 should be ordered relative to each 
      other. 
   genvec1 and genvec2 must have the same length. */
compare_genvecs_s := function(genvec1, genvec2)
   ordering := 0;
   i := 1;
   while ordering eq 0 do
      /* gens compared are equal */
      gen1 := genvec1[i];
      gen2 := genvec2[i];
      ordering := compare_gens(gen1, gen2);
      i +:= 1;
   end while;
   return ordering;
end function;

/* This function is a comparison function to be used in sorting lists of
      connected generating vectors, or lists of permutations, lexicographically
      for nonsolvable groups.
   It determines how genvec1 and genvec2 should be ordered relative to each 
      other. 
   genvec1 and genvec2 must have the same length. Corresponding elements of
      genvec1 and genvec2 must have the same cycle type and be sorted by the 
      numbers in the cycle type. 
*/
compare_genvecs_ns := function(genvec1, genvec2)
   for i in [1..#genvec1] do
      perm1 := genvec1[i];
      perm2 := genvec2[i];
      cycles1 := Split(perm1, ")(");
      cycles2 := Split(perm2, ")(");
      for i in [1..#cycles1] do
         nums1 := Split(cycles1[i], ", ");
         nums2 := Split(cycles2[i], ", ");
         for j in [1..#nums1] do
            num1 := StringToInteger(nums1[j]);
            num2 := StringToInteger(nums2[j]);
            ordering := num1 - num2;
            if ordering ne 0 then
               return ordering;
            end if;
         end for;
      end for;
   end for;
   return 0;
end function;

/* This function takes in a permutation (string), sorts it by the numbers 
      in the cycle type, and returns the sorted version as a string */
rewrite_perm := function(perm)
   perm_str := Sprintf("%o", perm);
   cycles := Split(perm_str, ")(");
   lengths := [#cycle : cycle in cycles];
   ParallelSort(~lengths, ~cycles);
   new_str := "(";
   for cycle in cycles do
      new_str := new_str cat cycle cat ")(";
   end for;
   return Substring(new_str, 1, #new_str-1);
end function;



/* This procedure sorts connected_genvecs based on group_solvable 

   If group_solvable, then connected_genvecs is sorted according to how 
      to_sort_genvecs is sorted. to_sort_genvecs is sorted lexicographically 
      by comparing corresponding elements of the vectors

   The elements of the genvecs in connected_genvecs are written in terms of
      powers, while the corresponding elements in to_sort_genvecs are 
      expanded from their powers.
         Ex: a^4b -> aaaab
      If we have a letter raised to a negative power (inverse), then
         consider the positive power version and its expansion.
            Ex: if b has order 4, then b^-1 = b^3 -> bbb

   When making comparisons, Id(G) takes precedence, then alphabetical order
      is considered.
      Ex: if a^-1b = aaab, then
         Id(G) < a < aa < aaab < aab < ab < abb < abc < b
         Id(G) < a < a^2 < a^-1b < a^2b < ab < ab^2 < abc < b
*/
sort_connected_genvecs := procedure(~connected_genvecs, ~to_sort_genvecs,\
                                    group_solvable)
   if group_solvable then
      ParallelSort(~to_sort_genvecs, ~connected_genvecs);
   else
      Sort(~connected_genvecs, compare_genvecs_ns);
   end if;
end procedure;



/* The following procedures are called in the for loop over Ldata. */

/* This procedure computes the connected genvec of rec and appends it to 
      the list connected_genvecs. */
append_connected_genvec := procedure(~connected_genvecs, ~to_sort_genvecs,\
                                     rec, iso, small_group, G, G_to_pc)
   genvec := rec`genimages;       
   if IsSolvable(small_group) then
      connected_genvec := [];
      to_sort_genvec := [];
      for gen in genvec do
         processed_gen, to_sort_gen := process_gen(iso(gen), G, G_to_pc);
         Append(~connected_genvec, processed_gen);
         Append(~to_sort_genvec, to_sort_gen);
      end for;
      Append(~connected_genvecs, connected_genvec);
      Append(~to_sort_genvecs, to_sort_genvec);
   else
      rewritten_genvec := [];
      for perm in genvec do
         Append(~rewritten_genvec, rewrite_perm(perm));
      end for;
      Append(~connected_genvecs, rewritten_genvec);
   end if;
end procedure;

/* This function unpacks the conjugacy class info in cc_info and returns
      two lists containing the info. */
unpack_cc_info := function(cc_info)
   con := [];
   con_label := [];
   for pair in cc_info do 
      Append(~con, pair[1]);
      Append(~con_label, pair[2]);
   end for;
   return con, con_label;
end function;



/* Iterate over Ldata to compute the data to be outputted in a txt file. */
for ell in Ldata do
   sign := ell[1];
   order := ell[2,1];
   counter := ell[2,2];

   small_group := SmallGroup(order, counter);

   group_label := Sprintf("%o.%o", order, counter);

   try
      data := db_data[group_label];
   catch e
      printf "%o is not in the groups db\n", group_label;
      continue;
   end try;

   perm_gens := data[5];
   if Type(perm_gens) eq MonStgElt and perm_gens eq "error" then 
      printf "perm_gens not available for %o\n", group_label;
      continue;
   end if;

   sign_str := IntegerToString(sign[1]);
   for i in [2..#sign] do
      sign_str := sign_str cat "." cat IntegerToString(sign[i]);
   end for;

   /* No conjugacy classes available, so append 0 to sign_str */
   if #sign eq 1 then
       sign_str := Sprintf("%o.0", sign_str);
   end if;

   label := Sprintf("%o.%o-%o.%o", gxx, IntegerToString(order),\
                                   IntegerToString(counter), sign_str);

   iso := "";
   G_to_pc := "";
   G := "";

   /* Compute isomorphism between monodromy group and the group on abstract
         groups page depending on whether the group is solvable or not */
   /* Group is solvable */
   if IsSolvable(small_group) then

      /* Get the PC group decoded from the pc_code */
      pc_code := data[1];
      try
         pc_group := SmallGroupDecoding(pc_code, order);
      catch e
         printf "Error decoding PC group for %o\n", group_label;
         continue;
      end try;

      /* Check that ngens matches the number of generators in PC group */
      ngens := data[2];
      if ngens ne NumberOfGenerators(pc_group) then
	 message := Sprintf("Number of generators in PC group does not " cat \
                            "match ngens in groups db: %o\n", [order,counter]);
         error message;
      end if;

      /* Corresponding permutation group created from the SmallGroup */
      perm_group_mon := PermRep(small_group);

      /* Compute generating vectors and conjugacy classes */
      recs := RepresentativesEpimorphisms(sign, perm_group_mon);

      fp_group, fp_to_pc := FPGroup(pc_group); 
      pc_to_fp := Inverse(fp_to_pc);

      /* Simplify the generators and relations from the PC group, preserving
            the generators in gens_used */
      gens_used := data[3];
      G, fp_to_G := Simplify(fp_group : Preserve := gens_used);

      /* G is an FP group, so it cannot be passed to IsIsomorphic.
         Instead, create perm_to_pc, an isomorphism from the monodromy group to
            the decoded PC group. Then compose all the isomorphisms. */
      bool, perm_to_pc := IsIsomorphic(perm_group_mon, pc_group);
      pc_to_G := pc_to_fp * fp_to_G;
      G_to_pc := Inverse(pc_to_G);
      iso := perm_to_pc * pc_to_G;


   /* Group is nonsolvable, so the abstract groups page has a permutation
         representation of the group */
   else
      degree := data[4];
      group_str := Sprintf("PermutationGroup<%o|%o>", degree, perm_gens);
      perm_group_rep := eval group_str;

      recs := RepresentativesEpimorphisms(sign, perm_group_rep);

   end if;

   /* Sort recs by conjugacy class label vectors and replace values in the Con
         fields with index, label pairs */
   sort_recs_by_cc_label(~recs, small_group);

   /* Compute the data to be outputted in a txt file */

   /* Data for the first record */
   suffix := 1;
   passport_label := Sprintf("%o.%o", label, suffix);
   connected_genvecs := []; 
   to_sort_genvecs := [];
   append_connected_genvec(~connected_genvecs, ~to_sort_genvecs,\
                           recs[1], iso, small_group, G, G_to_pc);
   prev_cc := recs[1]`Con;
   con, con_label := unpack_cc_info(prev_cc);

   for i in [2..#recs] do
      cur_cc := recs[i]`Con;

      if (prev_cc ne cur_cc) or (prev_cc eq [] and cur_cc eq []) then
         /* If prev_cc neq cur_cc, we have a new conjugacy class vector, 
               so add the data computed for the previous 
               conjugacy class vector/passport_label.
            If prev_cc eq [] and cur_cc eq [], then there are no conjugacy
               classes available for both. Treat them as associated with 
               different passport labels. */

         sort_connected_genvecs(~connected_genvecs, ~to_sort_genvecs,\
                                IsSolvable(small_group));

         /* Form total labels and add the data */
         for i in [1..#connected_genvecs] do
            total_label := Sprintf("%o.%o", passport_label, i);
            line := Sprintf("%o|%o|%o|%o|%o\n", total_label, passport_label,\
                             con, con_label, connected_genvecs[i]);
            output_str := output_str cat line;
         end for;

         /* Set new values according to the new conjugacy class vector */
         prev_cc := cur_cc;
         suffix +:= 1;
         passport_label := Sprintf("%o.%o", label, suffix);
         connected_genvecs := [];
         to_sort_genvecs := [];
         con, con_label := unpack_cc_info(cur_cc);

      end if;
  
      append_connected_genvec(~connected_genvecs, ~to_sort_genvecs,\
                              recs[i], iso, small_group, G, G_to_pc);

   end for;

   /* Add data for the last conjugacy class vector */
   sort_connected_genvecs(~connected_genvecs, ~to_sort_genvecs,\
                          IsSolvable(small_group));
   for i in [1..#connected_genvecs] do
      total_label := Sprintf("%o.%o", passport_label, i);
      line := Sprintf("%o|%o|%o|%o|%o\n", total_label, passport_label,\
                     con, con_label, connected_genvecs[i]);
      output_str := output_str cat line;
   end for;

end for;


PrintFile(output_file, output_str);

