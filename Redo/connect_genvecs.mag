/* This program connects generating vectors of monodromy groups to the
      corresponding generators on the abstract groups pages, connects
      conjugacy class vectors to the corresponding labels on the abstract
      groups pages, and uses a new labeling convention for total_label and 
      passport_label. 
   Data of the form total_label|passport_label|con|con_label|connected_genvec
      is printed to a txt file.
*/

/* Set the variable gxx below to the desired genus and also replace gxx in
      the string for the input file. */
gxx:=2;

/* Input file */
load "SupplementaryFiles/BreuerRaw/g02";



if gxx lt 10 then
   genus_str := "0" cat IntegerToString(gxx);
else
   genus_str := IntegerToString(gxx);
end if;


/* Output file */
output_file := Sprintf("g%o_connected_genvecs.txt", genus_str);

output_str := "total_label|passport_label|con|con_label|connected_genvec" cat
              "\ntext|text|text|text|jsonb\n\n";


/* load gps_decode, a list (generated by a Python script) containing
      data from the groups db needed to construct groups in magma */
load "gps_decode.mag";

/* load RepresentativesEpimorphisms  */
load "genvectors.mag";

/* load PermRep */
load "ries_helper_fn.mag";

/* for ordercc function */
Attach("orderCC.m");

/* dependencies of orderCC.m */
Attach("mb-gp-elts.m");
Attach("random.m");



/* Create associative array of groups data, indexed by gp_label, for
      quick accessing */
db_data := AssociativeArray();
for gp in gps_decode do
   gp_label := gp[1];
   db_data[gp_label] := [* gp[2], gp[3], gp[4], gp[5], gp[6] *];
end for;



/* Regex patterns for magma generators */
identity_regex := "Id\\(\\$\\)";
base_regex := "\\$.(-?[0-9]+)";
power_regex := "\\^(-?[0-9]+)";
conjugate_regex := "\\^\\$.(-?[0-9]+)";

/* This function takes in a generator from a generating vector and returns
      it written in terms of letters from the abstract groups page. */
process_gen := function(gen, group_solvable)

   if not group_solvable then
      return gen;
   end if;

   parts := Split(gen, " * ");
   letters := [];
   for p in parts do
      /* p has one of the following forms: $.i, $.i^j, $.i^$.j, Id($) */
      is_match, match, match_seq := Regexp(identity_regex, p);
      if is_match then
         /* p has the form Id($) */
         Append(~letters, "Id(G)");
      else
         is_match, match, match_seq := Regexp(base_regex, p);
         i := match_seq[1];
         /* 1 -> a, 2 -> b, and so on */
         letter := CodeToString(StringToInteger(i)+96);
         if match eq p then
            /* p has the form $.i */
            Append(~letters, letter);
         else
            /* p has one of the following forms: $.i^j, $.i^$.j */
            remaining := Substring(p, #match+1, #p);
            is_match, match, match_seq := Regexp(power_regex, remaining);
            if is_match then
               /* p has the form $.i^j */
               j := match_seq[1];
               Append(~letters, Sprintf("%o^%o", letter, j));
            else
               /* p has the form $.i^$.j */
               is_match, match, match_seq := Regexp(conjugate_regex, remaining);
               j := match_seq[1];
               letter2 := CodeToString(StringToInteger(j)+96);
               Append(~letters, Sprintf("%o^%o", letter, letter2));
            end if;
         end if;
      end if;
   end for;
 
   /* Iterate backwards through letters to build processed_gen so that 
         evaluating from right to left gives the correct permutation */
   processed_gen := "";
   for i:=#letters to 1 by -1 do
      processed_gen := processed_gen cat letters[i];
   end for;

   return processed_gen;

end function;



/* This procedure sorts records from RepresentativesEpimorphisms
      by conjugacy class label vectors and replaces recs[i]`Con
      with index, label pairs. */
sort_recs_by_cc_label := procedure(~recs, G)
   cc := ConjugacyClasses(G);
   cm := ClassMap(G);
   pm := PowerMap(G);
   gens := Generators(G);
   reps, finalkeys, cc_labels := ordercc(G, cc, cm, pm, gens);

   /* Create associative array of conjugacy class label and sorting info,
         indexed by conjugacy class representative */
   A := AssociativeArray();
   for i in [1..#reps] do
      A[reps[i]] := [* cc_labels[i], finalkeys[i] *];
   end for;

   /* Create to_sort, a list corresponding to conjugacy class label vectors
         containing info on how to sort them */
   to_sort := [];
   for i in [1..#recs] do
      Con := recs[i]`Con;
      Con_pairs := [];
      sort_info := [];
      for i in Con do
	 cc_rep := cc[i][3];
         Append(~Con_pairs, [* i, A[cc_rep][1] *]);
         Append(~sort_info, A[cc_rep][2]);
      end for;
      /* Replace recs[i]`Con with a list of index, label pairs */
      recs[i]`Con := Con_pairs;
      Append(~to_sort, sort_info);
   end for;

   /* Sort to_sort lexicographically, performing the corresponding sort
         in recs */
   ParallelSort(~to_sort, ~recs);

end procedure;



/* Regex pattern for group generators on abstract groups pages */
group_gen_regex := "([a-z])(\\^-?[0-9]+)?";
identity_regex2 := "Id\\(G\\)";

/* This function is a helper function for compare_genvecs_s to
      determine the ordering of the connected generating vectors.
   gen1 and gen2 are elements of two different vectors, but they are
   at the same position in the two vectors (which have the same length). */
compare_gens := function(gen1, gen2)

   /* gen1, gen2 might be Id(G) */
   is_match1, match1, match_seq1 := Regexp(identity_regex2, gen1);
   is_match2, match2, match_seq2 := Regexp(identity_regex2, gen2);
   if is_match1 and not is_match2 then
      return -1;
   elif is_match1 and is_match2 then
      return 0;
   elif not is_match1 and is_match2 then
      return 1;
   /* else, both gen1 and gen2 are not Id(G) */
   end if;

   remaining1 := gen1;
   remaining2 := gen2;
   while remaining1 ne "" and remaining2 ne "" do
      /* Continue comparing gen1 and gen2 */
      is_match1, match1, match_seq1 := Regexp(group_gen_regex, remaining1);
      is_match2, match2, match_seq2 := Regexp(group_gen_regex, remaining2);
      letter1 := match_seq1[1];
      letter2 := match_seq2[1];
      /* Order by alphabetical order of letters */
      ordering := StringToCode(letter1) - StringToCode(letter2);
      if ordering ne 0 then
         return ordering;
      end if;
      /* The letters are the same, so order by the power */
      /* If a letter is to the first power, then #match_seq eq 1.
         Otherwise, #match_seq eq 2. */
      ordering := #match_seq1 - #match_seq2;
      if ordering ne 0 then
         return ordering;
      end if;
      /* Either both are to the first power or both are not */
      if #match_seq1 eq 2 then
         /* Both have a power greater than 1, so order by that power treated
               as an integer */
         power1 := StringToInteger(Substring(match_seq1[2], 2, #match_seq1[2]));
         power2 := StringToInteger(Substring(match_seq2[2], 2, #match_seq2[2]));
         ordering := power1 - power2;
         if ordering ne 0 then
            return ordering;
         end if;
      end if;
      /* The letters and powers are the same, so start the process over 
            with the next letter */
      if match1 eq remaining1 then
         /* There is no next letter */
         remaining1 := "";
      else 
         /* Set remaining1 to the next sequence of letters */
         remaining1 := Substring(remaining1, #match1+1, #remaining1);
      end if;
      if match2 eq remaining2 then
         remaining2 := "";
      else
         remaining2 := Substring(remaining2, #match2+1, #remaining2);
      end if;
   end while;
   /* At least one of remaining1, remaining2 is the empty string */
   ordering := #remaining1 - #remaining2;
   return ordering;
end function;

/* This function is a comparison function to be used in sorting lists of
      connected generating vectors lexicographically for solvable groups.
   It determines how genvec1 and genvec2 should be ordered relative to each 
      other. 
   genvec1 and genvec2 must have the same length. */
compare_genvecs_s := function(genvec1, genvec2)
   ordering := 0;
   i := 1;
   while ordering eq 0 do
      /* gens compared are equal */
      gen1 := genvec1[i];
      gen2 := genvec2[i];
      ordering := compare_gens(gen1, gen2);
      i +:= 1;
   end while;
   return ordering;
end function;

/* This function is a comparison function to be used in sorting lists of
      connected generating vectors lexicographically for unsolvable groups.
   It determines how genvec1 and genvec2 should be ordered relative to each 
      other. 
   genvec1 and genvec2 must have the same length. */
compare_genvecs_ns := function(genvec1, genvec2)
   /* to do */
   return 0;
end function;

/* This procedure sorts connected_genvecs based on group_solvable */
sort_connected_genvecs := procedure(~connected_genvecs, group_solvable)
   if group_solvable then
      Sort(~connected_genvecs, compare_genvecs_s);
   else
      Sort(~connected_genvecs, compare_genvecs_ns);
   end if;
end procedure;



/* The following procedures are called in the for loop over Ldata. */

/* This procedure computes the connected genvec of rec and appends it to 
      the list connected_genvecs. */
append_connected_genvec := procedure(~connected_genvecs, rec, iso, Grp)
   genvec := rec`genimages;       
   connected_genvec := [];
   for gen in genvec do
      Append(~connected_genvec, process_gen(Sprintf("%o", iso(gen)),\
                                            IsSolvable(Grp)));
   end for;
   Append(~connected_genvecs, connected_genvec);
end procedure;

/* This function unpacks the conjugacy class info in cc_info and returns
      two lists containing the info. */
unpack_cc_info := function(cc_info)
   con := [];
   con_label := [];
   for pair in cc_info do 
      Append(~con, pair[1]);
      Append(~con_label, pair[2]);
   end for;
   return con, con_label;
end function;



/* Iterate over Ldata to compute the data to be outputted in a txt file. */
for ell in Ldata do
   sign := ell[1];
   order := ell[2,1];
   counter := ell[2,2];

   Grp := SmallGroup(order, counter);

   group_label := Sprintf("%o.%o", order, counter);

   try
      data := db_data[group_label];
   catch e
      printf "%o is not in the groups db\n", group_label;
      continue;
   end try;

   perm_gens := data[5];
   if Type(perm_gens) eq MonStgElt and perm_gens eq "error" then 
      printf "perm_gens not available for %o\n", group_label;
      continue;
   end if;

   /* Corresponding permutation group created from the SmallGroup */
   perm_group_mon := PermRep(Grp);

   /* Compute generating vectors and conjugacy classes */
   recs := RepresentativesEpimorphisms(sign, perm_group_mon);

   sign_str := IntegerToString(sign[1]);
   for i in [2..#sign] do
      sign_str := sign_str cat "." cat IntegerToString(sign[i]);
   end for;

   /* No conjugacy classes available, so append 0 to sign_str */
   if #sign eq 1 then
       sign_str := Sprintf("%o.0", sign_str);
   end if;

   label := Sprintf("%o.%o-%o.%o", gxx, IntegerToString(order),\
                                   IntegerToString(counter), sign_str);

   /* Compute isomorphism between monodromy group and the group on abstract
         groups page depending on whether the group is solvable or not */
   /* Group is solvable */
   if Type(perm_gens) eq MonStgElt and perm_gens eq "solvable" then

      /* Get the PC group decoded from the pc_code */
      pc_code := data[1];
      try
         pc_group := SmallGroupDecoding(pc_code, order);
      catch e
         printf "Error decoding PC group for %o\n", group_label;
         continue;
      end try;

      /* Check that ngens matches the number of generators in PC group */
      ngens := data[2];
      if ngens ne NumberOfGenerators(pc_group) then
	 message := Sprintf("Number of generators in PC group does not " cat \
                            "match ngens in groups db: %o\n", [order,counter]);
         error message;
      end if;

      fp_group, fp_to_pc := FPGroup(pc_group); 
      pc_to_fp := Inverse(fp_to_pc);

      /* Simplify the generators and relations from the PC group, preserving
            the generators in gens_used */
      gens_used := data[3];
      G, fp_to_G := Simplify(fp_group : Preserve := gens_used);

      /* G is an FP group, so it cannot be passed to IsIsomorphic.
         Instead, create perm_to_pc, an isomorphism from the monodromy group to
            the decoded PC group. Then compose all the isomorphisms. */
      bool, perm_to_pc := IsIsomorphic(perm_group_mon, pc_group);
      iso := perm_to_pc * pc_to_fp * fp_to_G;

   /* Group is unsolvable, so the abstract groups page has a permutation
         representation of the group */
   else
      degree := data[4];
      group_str := Sprintf("PermutationGroup<%o|%o>", degree, perm_gens);
      perm_group_rep := eval group_str;

      bool, iso := IsIsomorphic(perm_group_mon, perm_group_rep);

   end if;

   /* Sort recs by conjugacy class label vectors and replace values in the Con
         fields with index, label pairs */
   sort_recs_by_cc_label(~recs, Grp);

   /* Compute the data to be outputted in a txt file */

   /* Data for the first record */
   suffix := 1;
   passport_label := Sprintf("%o.%o", label, suffix);
   connected_genvecs := []; 
   append_connected_genvec(~connected_genvecs, recs[1], iso, Grp);
   prev_cc := recs[1]`Con;
   con, con_label := unpack_cc_info(prev_cc);

   for i in [2..#recs] do
      cur_cc := recs[i]`Con;

      if (prev_cc ne cur_cc) or (prev_cc eq [] and cur_cc eq []) then
         /* If prev_cc neq cur_cc, we have a new conjugacy class vector, 
               so add the data computed for the previous 
               conjugacy class vector/passport_label.
            If prev_cc eq [] and cur_cc eq [], then there are no conjugacy
               classes available for both. Treat them as associated with 
               different passport labels. */

         /* Sort connected_genvecs lexicographically according to the
               comparison function compare_genvecs_s */
         sort_connected_genvecs(~connected_genvecs, IsSolvable(Grp));

         /* Form total labels and add the data */
         for i in [1..#connected_genvecs] do
            total_label := Sprintf("%o.%o", passport_label, i);
            line := Sprintf("%o|%o|%o|%o|%o\n", total_label, passport_label,\
                             con, con_label, connected_genvecs[i]);
            output_str := output_str cat line;
         end for;

         /* Set new values according to the new conjugacy class vector */
         prev_cc := cur_cc;
         suffix +:= 1;
         passport_label := Sprintf("%o.%o", label, suffix);
         connected_genvecs := [];
         con, con_label := unpack_cc_info(cur_cc);

      end if;
  
      append_connected_genvec(~connected_genvecs, recs[i], iso, Grp);

   end for;

   /* Add data for the last conjugacy class vector */
   sort_connected_genvecs(~connected_genvecs, IsSolvable(Grp));
   for i in [1..#connected_genvecs] do
      total_label := Sprintf("%o.%o", passport_label, i);
      line := Sprintf("%o|%o|%o|%o|%o\n", total_label, passport_label,\
                     con, con_label, connected_genvecs[i]);
      output_str := output_str cat line;
   end for;

end for;


PrintFile(output_file, output_str);

