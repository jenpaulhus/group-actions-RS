from lmfdb import db

# Instructions:
# sage
# from gps_transitive import create_list
# create_list()

def create_list():
    '''
    Write the list gps_transitive to a magma file.
    The first element is the maximum order of abelian groups in the 
      gps_transitive db.
    Each subsequent element is [gapidfull, nTt, n, gens], where nTt, 
      generated by gens, is a transitive subgroup of Sn of minimal n 
      isomorphic to gapidfull.
    For solvable groups that are nonabelian or abelian and of order <= the max
      abelian order of groups in the db, this transitive subgroup is passed 
      into RepEpi.
    '''
    f = open('scripts/higher_genus_w_automorphisms/gps_transitive.mag', 'w')
    max_ab_order = db.gps_transitive.max('order', {'ab':1})
    output_str = f'gps_transitive := [* {str(max_ab_order)}, \n'
    gapidfull_list = db.gps_transitive.distinct('gapidfull')
    for gapidfull in gapidfull_list:
        # db.gps_transitive is sorted by [n, t], so we can just pick the first
        # entry from each gapidfull query to get the entry with minimal n and t
        iter = db.gps_transitive.search({'gapidfull':gapidfull})
        min_entry = next(iter)
        gens_str = ''
        for perm in min_entry['gens']:
            formatted_perm = [f'({str(p)[1:-1]})' for p in perm]
            formatted_perm = ''.join(formatted_perm)
            formatted_perm = f'\"{formatted_perm}\"'
            gens_str = gens_str + formatted_perm + ', '
        gens_str = '[' + gens_str[:-2] + ']'
        group_label = '.'.join(gapidfull[1:-1].split(','))
        group_label = f'\"{group_label}\"'
        label = min_entry['label']
        label = f'\"{label}\"'
        data_str = ', '.join([group_label, label, str(min_entry['n']), gens_str])
        output_str += f'[* {data_str} *],\n'
    output_str = output_str[:-2] + ' *];'
    f.write(output_str)
    f.close()
