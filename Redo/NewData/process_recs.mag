/* This program connects generating vectors of monodromy groups to the
      corresponding generators on the abstract groups pages, connects
      conjugacy class vectors to the corresponding labels on the abstract
      groups pages, and uses a new labeling convention for total_label and 
      passport_label. 
*/


/* load gps_decode, a list (generated by a Python script) containing
      data from the groups db needed to construct groups in magma */
load "gps_decode.mag";

load "gps_transitive.mag";

/* for FindOrbits function */
load "orbits.mag";

/* for ordercc function */
Attach("orderCC.m");

/* dependencies of orderCC.m */
Attach("mb-gp-elts.m");
Attach("random.m");


/* Create associative array of groups data, indexed by gp_label, for
      quick accessing */
gps_db := AssociativeArray();
for gp in gps_decode do
   gp_label := gp[1];
   gps_db[gp_label] := [* gp[2], gp[3], gp[4], gp[5], gp[6] *];
end for;

/* Create associative array of transitive groups to input into RepEpi, 
      indexed by gp_label, for quick accessing */
gps_trans_db := AssociativeArray();
for gp in gps_transitive do
   group_label := gp[1];
   gps_trans_db[group_label] := [* gp[2], gp[3] *];
end for;


/* Regex patterns for magma generators */
base_regex := "\\G.(-?[0-9]+)";
power_regex := "\\^(-?[0-9]+)";

/* This function takes in a generator from a generating vector of a solvable
      group and returns it written in terms of letters from the abstract 
      groups page, along with a version of it to be used in sorting.
   G_to_pc is used to rewrite inverse elements as elements raised
      to positive powers for the purpose of sorting.
*/
process_gen := function(gen, G, G_to_pc)

   gen_str := Sprintf("%o", gen);
   parts := Split(gen_str, " * ");

   /* When iterating through parts, processed_gen and to_sort_gen are built
         backwards so that evaluating from right to left gives the correct 
         permutation */
   processed_gen := "";
   to_sort_gen := "";

   for p in parts do
      /* p has one of the following forms: G.i, G.i^j, Id(G) */
      if p eq "Id(G)" then
         processed_gen := processed_gen cat "Id(G)";
         to_sort_gen := to_sort_gen cat "Id(G)";
      else
         is_match, base_match, match_seq := Regexp(base_regex, p);
         i := match_seq[1];
         /* 1 -> a, 2 -> b, and so on */
         letter := CodeToString(StringToInteger(i)+96);
         if base_match eq p then
            /* p has the form G.i */
            processed_gen := letter cat processed_gen;
            to_sort_gen := letter cat to_sort_gen;
         else
            /* p has the form G.i^j */
            remaining := Substring(p, #base_match+1, #p);
            is_match, match, match_seq := Regexp(power_regex, remaining);
            j := StringToInteger(match_seq[1]);
            processed_gen := Sprintf("%o^%o", letter, j) cat processed_gen;
            if j ge 2 then
               for k in [1..j] do
                  to_sort_gen := letter cat to_sort_gen;
               end for;
            else /* j is negative */
               /* The isomorphism G_to_pc maps G.i of the FP group G to the
                     corresponding element in the PC group so that we can use
                     the Order function */
               fp_ele := eval base_match;
               pc_ele := G_to_pc(fp_ele);
               order := Order(pc_ele);
               power := order + j;
               for k in [1..power] do
                  to_sort_gen := letter cat to_sort_gen;
               end for;
            end if;
         end if;
      end if;
   end for;

   return processed_gen, to_sort_gen;

end function;



/* This function sorts records from RepresentativesEpimorphisms
      by conjugacy class label vectors and returns Cons, Cons_label
      where Cons is the sorted list of conjugacy class vectors and 
      Cons_label is the corresponding list of conjugacy class vector labels */
sort_recs_by_cc_label := function(recs, group)
   cc := ConjugacyClasses(group);
   cm := ClassMap(group);
   pm := PowerMap(group);
   gens := Generators(group);
   reps, finalkeys, cc_labels := ordercc(group, cc, cm, pm, gens);

   /* Create associative array A indexed by conjugacy class representative. 
         Each element is [cc_label, finalkey], where cc_label is the conjugacy
         class label of the representative and finalkey is a list of numbers 
         that is used to sort the conjugacy class labels */
   A := AssociativeArray();
   for i in [1..#reps] do
      A[reps[i]] := [* Sprintf("\"%o\"", cc_labels[i]), finalkeys[i] *];
   end for;

   /* Create to_sort, a list containing info on how to sort recs by 
         conjugacy class label vectors */
   to_sort := [];
   for i in [1..#recs] do
      Con := recs[i]`Con;
      sort_info := [];
      for i in Con do
         cc_rep := cc[i][3];
         Append(~sort_info, A[cc_rep][2]);
      end for;
      Append(~to_sort, sort_info);
   end for;

   /* Sort to_sort lexicographically, performing the corresponding sort
         in recs */
   ParallelSort(~to_sort, ~recs);

   /* Create Cons and Cons_label to return */
   Cons := [];
   Cons_label := [];
   for rec in recs do
      Append(~Cons, rec`Con);
      Con_label := [];
      for i in rec`Con do
         cc_rep := cc[i][3];
	 Append(~Con_label, A[cc_rep][1]);
      end for;
      Append(~Cons_label, Con_label);
   end for;

   return recs, Cons, Cons_label;

end function;


/* This function is a comparison function to be used in sorting lists of
      connected generating vectors, or lists of permutations, lexicographically
      for nonsolvable groups.
   It determines how genvec1 and genvec2 should be ordered relative to each 
      other. 
   genvec1 and genvec2 must have the same length. Corresponding elements of
      genvec1 and genvec2 must have the same cycle type and be sorted by the 
      numbers in the cycle type. 
*/
compare_genvecs_ns := function(pair1, pair2)
   genvec1 := pair1[2];
   genvec2 := pair2[2];
   for i in [1..#genvec1] do
      perm1 := genvec1[i];
      perm2 := genvec2[i];
      cycles1 := Split(perm1, ")(");
      cycles2 := Split(perm2, ")(");
      for i in [1..#cycles1] do
         nums1 := Split(cycles1[i], ", ");
         nums2 := Split(cycles2[i], ", ");
         for j in [1..#nums1] do
            num1 := StringToInteger(nums1[j]);
            num2 := StringToInteger(nums2[j]);
            ordering := num1 - num2;
            if ordering ne 0 then
               return ordering;
            end if;
         end for;
      end for;
   end for;
   return 0;
end function; 


/* This function takes in a permutation (string), sorts it by the numbers 
      in the cycle type, and returns the sorted version as a string */
rewrite_perm := function(perm)
   perm_str := Sprintf("%o", perm);
   cycles := Split(perm_str, ")(");
   nums := [Split(cycle, ",") : cycle in cycles];
   lengths := [#ls : ls in nums];

   ParallelSort(~lengths, ~cycles);

   new_str := "(";
   for i in [1..#cycles] do
      new_str := new_str cat cycles[i] cat ")(";
   end for;
   return Substring(new_str, 1, #new_str-1);
end function;



/* This procedure sorts connected_genvecs based on group_solvable 

   If group_solvable, then connected_genvecs is sorted according to how 
      to_sort_genvecs is sorted. to_sort_genvecs is sorted lexicographically 
      by comparing corresponding elements of the vectors

   The elements of the genvecs in connected_genvecs are written in terms of
      powers, while the corresponding elements in to_sort_genvecs are 
      expanded from their powers.
         Ex: a^4b -> aaaab
      If we have a letter raised to a negative power (inverse), then
         consider the positive power version and its expansion.
            Ex: if b has order 4, then b^-1 = b^3 -> bbb

   When making comparisons, Id(G) takes precedence, then alphabetical order
      is considered.
      Ex: if a^-1b = aaab, then
         Id(G) < a < aa < aaab < aab < ab < abb < abc < b
         Id(G) < a < a^2 < a^-1b < a^2b < ab < ab^2 < abc < b
*/




compute_iso := function(perm_group, pc_group, gens_used)

   fp_group, fp_to_pc := FPGroup(pc_group); 
   pc_to_fp := Inverse(fp_to_pc);

   /* Simplify the generators and relations from the PC group, preserving
         the generators in gens_used */
   G, fp_to_G := Simplify(fp_group : Preserve := gens_used);

   /* G is an FP group, so it cannot be passed to IsIsomorphic.
      Instead, create perm_to_pc, an isomorphism from the monodromy group to
         the decoded PC group. Then compose all the isomorphisms. */
   bool, perm_to_pc := IsIsomorphic(perm_group, pc_group);
   pc_to_G := pc_to_fp * fp_to_G;
   G_to_pc := Inverse(pc_to_G);
   iso := perm_to_pc * pc_to_G;

   return iso, G, G_to_pc;
end function;


/* This procedure computes the connected genvec of rec and appends it to 
      the list connected_genvecs. */
append_cc_genvec_s := procedure(~cc_genvecs, ~cc_connected_genvecs, ~cc_sortable_genvecs,\
                                rec, iso, G, G_to_pc)
   genvec := rec`genimages;   
   Append(~cc_genvecs, genvec);    
   connected_genvec := [];
   sortable_genvec := [];
   for gen in genvec do
      processed_gen, to_sort_gen := process_gen(iso(gen), G, G_to_pc);
      Append(~connected_genvec, processed_gen);
      Append(~sortable_genvec, to_sort_gen);
   end for;
   Append(~cc_connected_genvecs, connected_genvec);
   Append(~cc_sortable_genvecs, sortable_genvec);
end procedure;


append_cc_genvec_ns := procedure(~cc_genvecs, rec)
   pair := [* *];
   genvec := rec`genimages; 
   Append(~pair, genvec);
   rewritten_genvec := [];
   for perm in genvec do
      Append(~rewritten_genvec, rewrite_perm(perm));
   end for;
   Append(~pair, rewritten_genvec);
   Append(~cc_genvecs, pair);
end procedure;


sort_cc_genvecs_s := procedure(~cc_genvecs, ~cc_connected_genvecs, ~cc_sortable_genvecs)
   copy := cc_sortable_genvecs;
   ParallelSort(~cc_sortable_genvecs, ~cc_genvecs);
   ParallelSort(~copy, ~cc_connected_genvecs);
end procedure;


sort_cc_genvecs_ns := procedure(~cc_genvecs, ~cc_rewritten_genvecs, ~keys)
   copy := keys;
   ParallelSort(~keys, ~cc_genvecs);
   ParallelSort(~copy, ~cc_rewritten_genvecs);
end procedure;


append_genvec_data_s := procedure(~Lgenvects, ~connected_Lgenvects, ~cc_labels, 
                                  cc_genvecs, cc_connected_genvecs, cc_numb)
   genvec_numb := 1;
   for i in [1..#cc_genvecs] do
      Append(~Lgenvects, cc_genvecs[i]);
      Append(~connected_Lgenvects, cc_connected_genvecs[i]);
      Append(~cc_labels, [cc_numb, genvec_numb]);
      genvec_numb +:= 1;
   end for;
end procedure;


append_genvec_data_ns := procedure(~Lgenvects, ~rewritten_Lgenvects, ~cc_labels, 
                                   cc_genvecs, cc_numb);
   genvec_numb := 1;
   for i in [1..#cc_genvecs] do
      pair := cc_genvecs[i];
      Append(~Lgenvects, pair[1]);
      Append(~rewritten_Lgenvects, pair[2]);
      Append(~cc_labels, [cc_numb, genvec_numb]);
      genvec_numb +:= 1;
   end for;
end procedure;


/* cc_labels is sorted */
get_rec_data_s := function(recs, iso, G, G_to_pc)

   cc_labels := [];
   cc_numb := 1;

   Lgenvects := [];
   connected_Lgenvects := [];

   cc_connected_genvecs := []; 
   cc_genvecs := [];
   cc_sortable_genvecs := [];

   /* Data for the first record */
   append_cc_genvec_s(~cc_genvecs, ~cc_connected_genvecs, ~cc_sortable_genvecs,\
                      recs[1], iso, G, G_to_pc);
   prev_Con := recs[1]`Con;

   for i in [2..#recs] do
      cur_Con := recs[i]`Con;

      if (prev_Con ne cur_Con) or (prev_Con eq [] and cur_Con eq []) then
         /* If prev_Con ne cur_Con, we have a new conjugacy class vector, 
               so add the data computed for prev_Con
            If prev_Con eq [] and cur_Con eq [], then there are no conjugacy
               classes for both (cover is unramified). 
               Treat them as associated with different passport labels. */
	 sort_cc_genvecs_s(~cc_genvecs, ~cc_connected_genvecs, ~cc_sortable_genvecs);
         append_genvec_data_s(~Lgenvects, ~connected_Lgenvects, ~cc_labels,
                              cc_genvecs, cc_connected_genvecs, cc_numb);

         /* Set new values because we have a new conjugacy class vector */
         prev_Con := cur_Con;
         cc_genvecs := [];
         cc_connected_genvecs := [];
         cc_sortable_genvecs := [];
         cc_numb +:= 1;
      end if;
      
      append_cc_genvec_s(~cc_genvecs, ~cc_connected_genvecs, ~cc_sortable_genvecs,\
                         recs[i], iso, G, G_to_pc);
   end for;

   /* Add data for the last conjugacy class vector */
   sort_cc_genvecs_s(~cc_genvecs, ~cc_connected_genvecs, ~cc_sortable_genvecs);
   append_genvec_data_s(~Lgenvects, ~connected_Lgenvects, ~cc_labels,
                        cc_genvecs, cc_connected_genvecs, cc_numb);

   return cc_labels, Lgenvects, connected_Lgenvects;
end function;


get_rec_data_ns := function(recs)
   cc_labels := [];
   cc_numb := 1;

   Lgenvects := [];
   rewritten_Lgenvects := [];

   // List to hold elements of the form [genvec, rewritten_genvec]
   cc_genvecs := [];

   /* Data for the first record */
   append_cc_genvec_ns(~cc_genvecs, recs[1]);
   prev_Con := recs[1]`Con;

   for i in [2..#recs] do
      cur_Con := recs[i]`Con;

      if (prev_Con ne cur_Con) or (prev_Con eq [] and cur_Con eq []) then
         /* If prev_cc neq cur_cc, we have a new conjugacy class vector, 
               so add the data computed for the previous 
               conjugacy class vector/passport_label.
            If prev_cc eq [] and cur_cc eq [], then there are no conjugacy
               classes for both (cover is unramified). 
               Treat them as associated with different passport labels. */
         Sort(~cc_genvecs, compare_genvecs_ns);
         //sort_cc_genvecs_ns(~cc_genvecs, ~cc_rewritten_genvecs);
         append_genvec_data_ns(~Lgenvects, ~rewritten_Lgenvects, ~cc_labels, 
                               cc_genvecs, cc_numb);

         /* Set new values according to the new conjugacy class vector */
         prev_Con := cur_Con;
         cc_genvecs := [];
         cc_numb +:= 1;
      end if;
      append_cc_genvec_ns(~cc_genvecs, recs[i]);
   end for;

   /* Add data for the last conjugacy class vector */
   Sort(~cc_genvecs, compare_genvecs_ns);
   append_genvec_data_ns(~Lgenvects, ~rewritten_Lgenvects, ~cc_labels, 
                         cc_genvecs, cc_numb);

   return cc_labels, Lgenvects, rewritten_Lgenvects;
end function;


compute_rec_data := function(sign, small_group)
   tuple := IdentifyGroup(small_group);
   order := tuple[1];
   counter := tuple[2];
   group_label := Sprintf("%o.%o", order, counter);

   try
      data := gps_db[group_label];
   catch e
      printf "%o is not in the groups db\n", group_label;
      return 0,0,0,0,0,0,0,0;
   end try;

   perm_gens := data[5];
   if Type(perm_gens) eq MonStgElt and perm_gens eq "error" then 
      printf "perm_gens not available for %o\n", group_label;
      return 0,0,0,0,0,0,0,0;
   end if;

   /* Compute isomorphism between monodromy group and the group on abstract
         groups page depending on whether the group is solvable or not */
   /* Group is solvable */
   if IsSolvable(small_group) then
      /* Get the PC group decoded from the pc_code */
      pc_code := data[1];
      try
         pc_group := SmallGroupDecoding(pc_code, order);
      catch e
         printf "Error decoding PC group for %o\n", group_label;
         return 0,0,0,0,0,0,0,0;
      end try;

      try
         trans_data := gps_trans_db[group_label];
      catch e
         printf "%o is not in the transitive groups db\n", group_label;
         return 0,0,0,0,0,0,0,0;
      end try;

      /* Check that ngens matches the number of generators in PC group */
      ngens := data[2];
      if ngens ne NumberOfGenerators(pc_group) then
         message := Sprintf("Number of generators in PC group does not " cat \
			    "match ngens in groups db: %o\n", [order,counter]);
         error message;
      end if;

      degree := trans_data[1];
      perm_gens := trans_data[2];
      group_str := Sprintf("PermutationGroup<%o|%o>", degree, perm_gens);
      perm_group := eval group_str; // PermRep(small_group);
      gens_used := data[3];
      iso, G, G_to_pc := compute_iso(perm_group, pc_group, gens_used);
      recs := RepresentativesEpimorphisms(sign, perm_group);
      /* Sort recs by conjugacy class label vectors and replace values in the Con
            fields with index, label pairs */
      recs, Cons, Cons_label := sort_recs_by_cc_label(recs, small_group);
      cc_labels, Lgenvects, connected_Lgenvects := get_rec_data_s(recs, iso, G, G_to_pc);
      braids, topos := FindOrbits(perm_group, sign, Lgenvects, cc_labels, sign[1]);
      // group_str := Sprintf("PermRep(SmallGroup(%o,%o))", IntegerToString(order), IntegerToString(counter));
      return group_str, Cons, Cons_label, cc_labels, Lgenvects, connected_Lgenvects, braids, topos;
   else
      degree := data[4];
      group_str := Sprintf("PermutationGroup<%o|%o>", degree, perm_gens);
      perm_group := eval group_str;
      recs := RepresentativesEpimorphisms(sign, perm_group);
      recs, Cons, Cons_label := sort_recs_by_cc_label(recs, small_group);
      // Lgenvects is a list of permutations, rewritten_Lgenvects is a list of permutation strings
      cc_labels, Lgenvects, rewritten_Lgenvects := get_rec_data_ns(recs);
      braids, topos := FindOrbits(perm_group, sign, Lgenvects, cc_labels, sign[1]);
      // rewritten_Lgenvects is returned for connected_Lgenvects because it is already connected
      return group_str, Cons, Cons_label, cc_labels, rewritten_Lgenvects, rewritten_Lgenvects, braids, topos;
   end if; 
end function;


