/* This file contains the function compute_rec_data that computes some data 
   for the hgcwa db. Given a signature and group, the function calls RepEpi 
   and processes the result to compute additional data. In particular, it 
   connects the generating vectors to the corresponding generators of the 
   group on the abstract groups page, connects the conjugacy class indices
   to the corresponding labels on the abstract groups page, and assigns 
   labels for the generating vectors (last two numbers in total_label).
*/

/* load gps_decode, a list (generated by gps_decode.py) containing data 
   from the groups db needed to connect generating vectors */
load "gps_decode.mag";

/* load gps_transitive, a list (generated by gps_transitive.py) containing 
   data from the transitive groups db needed to construct a group to input
   into RepEpi */
load "gps_transitive.mag";

/* for FindOrbits function */
load "orbits.mag";

/* for ordercc function */
Attach("orderCC.m");

/* dependencies of orderCC.m */
Attach("mb-gp-elts.m");
Attach("random.m");


/* Create associative array of groups data, indexed by gp_label, for
   quick accessing */
gps_db := AssociativeArray();
for gp in gps_decode do
   gp_label := gp[1];
   gps_db[gp_label] := [* gp[2], gp[3], gp[4], gp[5], gp[6] *];
end for;

/* Create associative array of transitive groups to input into RepEpi, 
   indexed by gp_label, for quick accessing */
gps_trans_db := AssociativeArray();
max_ab_order := gps_transitive[1];
for i in [2..#gps_transitive] do
   gp := gps_transitive[i];
   group_label := gp[1];
   gps_trans_db[group_label] := [* gp[2], gp[3], gp[4] *];
end for;


/* *************************************
Function process_gen

This function is used for solvable groups.

Input: gen       element of a generating vector as an element of G,
                 an FPGroup isomorphic to the solvable permutation group
                 passed into RepEpi
       G         FPGroup isomorphic to the solvable permutation group passed 
                 into RepEpi
       G_to_pc   isomorphism from G to the decoded PCGroup; this is used to
                 map inverse elements to the PCGroup so that we can use the
                 Order function to rewrite them in terms of positive powers 
                 for the purpose of sorting
         
Outcome: return processed_gen_str, a string representing gen written in 
         terms of the generators on the abstract groups page, and also 
         return to_sort_gen_str, a version of processed_gen_str to be 
         used in sorting.
**************************************** */
process_gen := function(gen, G, G_to_pc)
   /* Regex patterns for magma generators */
   base_regex := "\\G.(-?[0-9]+)";
   power_regex := "\\^(-?[0-9]+)";

   parts := Split(Sprintf("%o", gen), " * ");
   processed_gen := [];
   to_sort_gen := [];

   for p in parts do
      /* p has one of the following forms: G.i, G.i^j, Id(G) */
      if p eq "Id(G)" then
         Append(~processed_gen, "Id(G)");
         Append(~to_sort_gen, "Id(G)");
      else /* p has one of the following forms: G.i, G.i^j */
         is_match, base_match, match_seq := Regexp(base_regex, p);
         i := match_seq[1];
         /* 1 -> a, 2 -> b, and so on */
         letter := CodeToString(StringToInteger(i)+96);
         if base_match eq p then
            /* p has the form G.i */
            Append(~processed_gen, letter);
            Append(~to_sort_gen, letter);
         else /* p has the form G.i^j */
            remaining := Substring(p, #base_match+1, #p);
            is_match, match, match_seq := Regexp(power_regex, remaining);
            j := StringToInteger(match_seq[1]);
            Append(~processed_gen, Sprintf("%o^%o", letter, j));
            if j ge 2 then
               for k in [1..j] do
                  Append(~to_sort_gen, letter);
               end for;
            else /* j is negative */
               fp_ele := eval base_match;
               pc_ele := G_to_pc(fp_ele);
               order := Order(pc_ele);
               power := order + j;
               for k in [1..power] do
                  Append(~to_sort_gen, letter);
               end for;
            end if;
         end if;
      end if;
   end for;
   /* Reverse processed_gen and to_sort_gen so that evaluating from 
      right to left gives the correct permutation */
   processed_gen := Reverse(processed_gen);
   to_sort_gen := Reverse(to_sort_gen);
   
   processed_gen_str := "";
   to_sort_gen_str := "";
   for gen in processed_gen do
      processed_gen_str := processed_gen_str cat gen;
   end for;
   for gen in to_sort_gen do
      to_sort_gen_str := to_sort_gen_str cat gen;
   end for;

   return processed_gen_str, to_sort_gen_str;
end function;


/* *************************************
Function rewrite_perm

This function is used for nonsolvable groups.

Input: perm   permutation
 
Outcome: sort perm by the numbers defining the cycle type and return
         the sorted version as a string.
**************************************** */
rewrite_perm := function(perm)
   cycles := Split(Sprintf("%o", perm), ")(");
   nums := [Split(cycle, ",") : cycle in cycles];
   lengths := [#ls : ls in nums];
   ParallelSort(~lengths, ~cycles);
   new_str := "(";
   for i in [1..#cycles] do
      new_str := new_str cat cycles[i] cat ")(";
   end for;
   return Substring(new_str, 1, #new_str-1);
end function;


/* *************************************
Procedure append_to_cc_genvecs_s

This procedure is used for solvable groups.

Input: cc_genvecs             list of generating vectors for a particular
                              conjugacy class vector
       cc_connected_genvecs   list of connected generating vectors for a 
                              particular conjugacy class vector
       cc_sortable_genvecs    list of sortable connected generating vectors 
                              for a particular conjugacy class vector
       rec                    a record from RepEpi
       iso                    iso as returned by compute_iso
       G                      G as returned by compute_iso
       G_to_pc                G_to_pc as returned by compute_iso
 
Outcome: append an additional generating vector to the lists cc_genvecs,
         cc_connected_genvecs, and cc_sortable_genvecs by processing rec.
**************************************** */
append_to_cc_genvecs_s := procedure(~cc_genvecs, ~cc_connected_genvecs, 
                                ~cc_sortable_genvecs, rec, iso, G, G_to_pc)
   genvec := rec`genimages;   
   Append(~cc_genvecs, genvec);    
   connected_genvec := [];
   sortable_genvec := [];
   for gen in genvec do
      processed_gen, to_sort_gen := process_gen(iso(gen), G, G_to_pc);
      Append(~connected_genvec, processed_gen);
      Append(~sortable_genvec, to_sort_gen);
   end for;
   Append(~cc_connected_genvecs, connected_genvec);
   Append(~cc_sortable_genvecs, sortable_genvec);
end procedure;


/* *************************************
Procedure append_to_cc_genvecs_ns

This procedure is used for nonsolvable groups.

Input: cc_genvecs   list of [genvec, rewritten_genvec] for a particular
                    conjugacy class vector, where genvec is a list of 
                    GrpPermElts and rewritten_genvec is a list of strings
       rec          a record from RepEpi

Outcome: append an additional pair to the list cc_genvecs by processing rec.
**************************************** */
append_to_cc_genvecs_ns := procedure(~cc_genvecs, rec)
   pair := [* *];
   genvec := rec`genimages; 
   Append(~pair, genvec);
   rewritten_genvec := [];
   for perm in genvec do
      Append(~rewritten_genvec, rewrite_perm(perm));
   end for;
   Append(~pair, rewritten_genvec);
   Append(~cc_genvecs, pair);
end procedure;


/* *************************************
Procedure sort_cc_genvecs_s

This procedure is used for solvable groups.

Input: cc_genvecs             list of generating vectors for a particular
                              conjugacy class vector
       cc_connected_genvecs   list of connected generating vectors for a 
                              particular conjugacy class vector
       cc_sortable_genvecs    list of sortable connected generating vectors 
                              for a particular conjugacy class vector

Outcome: sort cc_genvecs and cc_connected_genvecs by using cc_sortable_genvecs.

The elements of the genvecs in cc_sortable_genvecs are expanded from their 
powers in cc_connected_genvecs.
   Ex: a^4b -> aaaab
Whenever there are inverse elements in genvecs of cc_connected_genvecs, the
corresponding expanded positive power version is in cc_sortable_genvecs.
   Ex: if b has order 4, then b^-1 = b^3 -> bbb

In sorting cc_sortable_genvecs, Id(G) takes precedence, then alphabetical 
order is considered.
   Ex: if a^-1b = aaab, then
       Id(G) < a < aa < aaab < aab < ab < abb < abc < b
       Id(G) < a < a^2 < a^-1b < a^2b < ab < ab^2 < abc < b
**************************************** */
sort_cc_genvecs_s := procedure(~cc_genvecs, ~cc_connected_genvecs, 
                               ~cc_sortable_genvecs)
   copy := cc_sortable_genvecs;
   ParallelSort(~cc_sortable_genvecs, ~cc_genvecs);
   ParallelSort(~copy, ~cc_connected_genvecs);
end procedure;


/* *************************************
Function compare_genvecs_ns

This function is a comparison function to be used in sorting lists of 
connected generating vectors of nonsolvable groups. Since the groups are 
nonsolvable, the connected generating vectors are lists of permutations.

Input: pair1   [genvec1, rewritten_genvec1], where genvec1 is a list of 
               GrpPermElts and rewritten_genvec1 is a list of strings
       pair2   [genvec2, rewritten_genvec2], where genvec2 is a list of 
               GrpPermElts and rewritten_genvec2 is a list of strings

       pair1[2] and pair2[2] must have the same length. 
       Corresponding elements of pair1[2] and pair2[2] must have the same 
       cycle type and be sorted by the numbers defining the cycle type. 

Outcome: determine how pair1[2] and pair2[2] should be ordered relative to 
         each other.
**************************************** */
compare_genvecs_ns := function(pair1, pair2)
   genvec1 := pair1[2];
   genvec2 := pair2[2];
   for i in [1..#genvec1] do
      perm1 := genvec1[i];
      perm2 := genvec2[i];
      cycles1 := Split(perm1, ")(");
      cycles2 := Split(perm2, ")(");
      for i in [1..#cycles1] do
         nums1 := Split(cycles1[i], ", ");
         nums2 := Split(cycles2[i], ", ");
         for j in [1..#nums1] do
            num1 := StringToInteger(nums1[j]);
            num2 := StringToInteger(nums2[j]);
            ordering := num1 - num2;
            if ordering ne 0 then
               return ordering;
            end if;
         end for;
      end for;
   end for;
   return 0;
end function; 


/* *************************************
Procedure append_to_Lgenvects_s

This procedure is used for solvable groups.

Input: Lgenvects              sorted list of generating vectors
       connected_Lgenvects    sorted list of connected generating vectors
       cc_labels              sorted list of labels 
                              (last two numbers in total_label)
       cc_genvecs             sorted list of generating vectors for a 
                              particular conjugacy class vector
       cc_connected_genvecs   sorted list of connected generating vectors 
                              for a particular conjugacy class vector
       cc_numb                number denoting the position of the conjugacy 
                              class vector in the sorted list of conjugacy 
                              class vectors

Outcome: append new elements to the lists Lgenvects, connected_Lgenvects,
         and cc_labels by using cc_genvecs, cc_connected_genvecs, and cc_numb
         respectively.
**************************************** */
append_to_Lgenvects_s := procedure(~Lgenvects, ~connected_Lgenvects, ~cc_labels, 
                                  cc_genvecs, cc_connected_genvecs, cc_numb)
   genvec_numb := 1;
   for i in [1..#cc_genvecs] do
      Append(~Lgenvects, cc_genvecs[i]);
      Append(~connected_Lgenvects, cc_connected_genvecs[i]);
      Append(~cc_labels, [cc_numb, genvec_numb]);
      genvec_numb +:= 1;
   end for;
end procedure;


/* *************************************
Procedure append_to_Lgenvects_ns

This procedure is used for nonsolvable groups.

Input: Lgenvects              sorted list of generating vectors
       rewritten_Lgenvects    sorted list of lists of permutation strings
       cc_labels              sorted list of labels 
                              (last two numbers in total_label)
       cc_genvecs             list of pairs [genvec, rewritten_genvec] sorted
                              by compare_genvecs_ns for a particular conjugacy 
                              class vector
       cc_numb                number denoting the position of the conjugacy 
                              class vector in the sorted list of conjugacy 
                              class vectors

Outcome: append new elements to the lists Lgenvects, rewritten_Lgenvects,
         and cc_labels by using cc_genvecs and cc_numb respectively.
**************************************** */
append_to_Lgenvects_ns := procedure(~Lgenvects, ~rewritten_Lgenvects, ~cc_labels, 
                                   cc_genvecs, cc_numb);
   genvec_numb := 1;
   for i in [1..#cc_genvecs] do
      pair := cc_genvecs[i];
      Append(~Lgenvects, pair[1]);
      Append(~rewritten_Lgenvects, pair[2]);
      Append(~cc_labels, [cc_numb, genvec_numb]);
      genvec_numb +:= 1;
   end for;
end procedure;


/* *************************************
Function get_rec_data_s

This procedure is used for solvable groups.

Input: recs      sorted list of records from RepEpi
       iso       iso as returned by compute_iso
       G         G as returned by compute_iso
       G_to_pc   G_to_pc as returned by compute_iso

Outcome: return cc_labels, Lgenvects, connected_Lgenvects, where cc_labels 
         is a sorted list of labels (last two numbers in total_label), 
         Lgenvects is a sorted list of generating vectors, and 
         connected_Lgenvects is a sorted list of connected generating vectors.
**************************************** */
get_rec_data_s := function(recs, iso, G, G_to_pc)

   cc_labels := [];
   cc_numb := 1;

   Lgenvects := [];
   connected_Lgenvects := [];

   cc_connected_genvecs := []; 
   cc_genvecs := [];
   cc_sortable_genvecs := [];

   /* Get data for the first record */
   append_to_cc_genvecs_s(~cc_genvecs, ~cc_connected_genvecs,
                          ~cc_sortable_genvecs, recs[1], iso, G, G_to_pc);
   prev_Con := recs[1]`Con;

   for i in [2..#recs] do
      cur_Con := recs[i]`Con;

      if (prev_Con ne cur_Con) or (prev_Con eq [] and cur_Con eq []) then
         /* If prev_Con ne cur_Con, we have a new conjugacy class vector, 
               so sort and append the data for prev_Con.
            If prev_Con eq [] and cur_Con eq [], then there are no conjugacy
               classes for both (cover is unramified). Treat them as 
               associated with different passport labels. */
	      sort_cc_genvecs_s(~cc_genvecs, ~cc_connected_genvecs, 
                           ~cc_sortable_genvecs);
         append_to_Lgenvects_s(~Lgenvects, ~connected_Lgenvects, ~cc_labels,
                               cc_genvecs, cc_connected_genvecs, cc_numb);
         /* Set new values since we have a new conjugacy class vector */
         prev_Con := cur_Con;
         cc_genvecs := [];
         cc_connected_genvecs := [];
         cc_sortable_genvecs := [];
         cc_numb +:= 1;
      end if;
      append_to_cc_genvecs_s(~cc_genvecs, ~cc_connected_genvecs, 
                             ~cc_sortable_genvecs, recs[i], iso, G, G_to_pc);
   end for;

   /* Append data for the last conjugacy class vector */
   sort_cc_genvecs_s(~cc_genvecs, ~cc_connected_genvecs, ~cc_sortable_genvecs);
   append_to_Lgenvects_s(~Lgenvects, ~connected_Lgenvects, ~cc_labels,
                         cc_genvecs, cc_connected_genvecs, cc_numb);
   return cc_labels, Lgenvects, connected_Lgenvects;
end function;


/* *************************************
Function get_rec_data_ns

This procedure is used for nonsolvable groups.

Input: recs   sorted list of records from RepEpi

Outcome: return cc_labels, Lgenvects, rewritten_Lgenvects, where cc_labels 
         is a sorted list of labels (last two numbers in total_label), 
         Lgenvects is a sorted list of generating vectors, and 
         rewritten_Lgenvects is a sorted list of lists of permutation strings.
**************************************** */
get_rec_data_ns := function(recs)

   cc_labels := [];
   cc_numb := 1;

   Lgenvects := [];
   rewritten_Lgenvects := [];

   /* List to hold elements of the form [genvec, rewritten_genvec] */
   cc_genvecs := [];

   /* Get data for the first record */
   append_to_cc_genvecs_ns(~cc_genvecs, recs[1]);
   prev_Con := recs[1]`Con;

   for i in [2..#recs] do
      cur_Con := recs[i]`Con;

      if (prev_Con ne cur_Con) or (prev_Con eq [] and cur_Con eq []) then
         /* If prev_Con ne cur_Con, we have a new conjugacy class vector, 
               so sort and append the data for prev_Con.
            If prev_Con eq [] and cur_Con eq [], then there are no conjugacy
               classes for both (cover is unramified). Treat them as 
               associated with different passport labels. */
         Sort(~cc_genvecs, compare_genvecs_ns);
         append_to_Lgenvects_ns(~Lgenvects, ~rewritten_Lgenvects, ~cc_labels, 
                                cc_genvecs, cc_numb);
         /* Set new values since we have a new conjugacy class vector */
         prev_Con := cur_Con;
         cc_genvecs := [];
         cc_numb +:= 1;
      end if;
      append_to_cc_genvecs_ns(~cc_genvecs, recs[i]);
   end for;

   /* Append data for the last conjugacy class vector */
   Sort(~cc_genvecs, compare_genvecs_ns);
   append_to_Lgenvects_ns(~Lgenvects, ~rewritten_Lgenvects, ~cc_labels, 
                          cc_genvecs, cc_numb);
   return cc_labels, Lgenvects, rewritten_Lgenvects;
end function;


/* *************************************
Function sort_recs_by_cc_label

Input: recs   records as returned by RepEpi
       G      group as returned by SmallGroup

Outcome: sort recs by conjugacy class label vectors and return 
         recs, Cons, Cons_label, where Cons is the list of conjugacy class 
         index vectors after sorting and Cons_label is the sorted list 
         of conjugacy class label vectors.
**************************************** */
sort_recs_by_cc_label := function(recs, G)
   cc := ConjugacyClasses(G);
   cm := ClassMap(G);
   pm := PowerMap(G);
   gens := Generators(G);
   reps, finalkeys, cc_labels := ordercc(G, cc, cm, pm, gens);

   /* Create associative array A indexed by conjugacy class representative. 
      Each element is [cc_label, finalkey], where cc_label is the conjugacy
      class label of the representative and finalkey is a list of numbers 
      that is used to sort the conjugacy class labels */
   A := AssociativeArray();
   for i in [1..#reps] do
      A[reps[i]] := [* Sprintf("\"%o\"", cc_labels[i]), finalkeys[i] *];
   end for;

   /* Create to_sort, a list containing info on how to sort recs by 
      conjugacy class label vectors */
   to_sort := [];
   for i in [1..#recs] do
      Con := recs[i]`Con;
      sort_info := [];
      for i in Con do
         cc_rep := cc[i][3];
         Append(~sort_info, A[cc_rep][2]);
      end for;
      Append(~to_sort, sort_info);
   end for;

   /* Sort to_sort lexicographically, performing the corresponding sort
      in recs */
   ParallelSort(~to_sort, ~recs);

   /* Create Cons and Cons_label to return */
   Cons := [];
   Cons_label := [];
   for rec in recs do
      Append(~Cons, rec`Con);
      Con_label := [];
      for i in rec`Con do
         cc_rep := cc[i][3];
	      Append(~Con_label, A[cc_rep][1]);
      end for;
      Append(~Cons_label, Con_label);
   end for;

   return recs, Cons, Cons_label;
end function;


/* *************************************
Function compute_iso

This function is used for solvable groups.

Input: perm_group   permutation group
       pc_group     decoded pc group
       gens_used    generators used for the pc group, as stored in the
                    groups db
 
Outcome: return iso, G, G_to_pc, where iso is an isomorphism from perm_group
         to G, G is an FPGroup of pc_group, and G_to_pc is an isomorphism
         from G to pc_group.
**************************************** */
compute_iso := function(perm_group, pc_group, gens_used)

   /* Convert pc_group to an FPGroup */
   fp_group, fp_to_pc := FPGroup(pc_group); 
   pc_to_fp := Inverse(fp_to_pc);

   /* Simplify the generators and relations from the PC group, preserving
      the generators in gens_used */
   G, fp_to_G := Simplify(fp_group : Preserve := gens_used);

   /* G is an FPGroup, so it cannot be passed to IsIsomorphic.
      Instead, create perm_to_pc, an isomorphism from perm_group to
      pc_group. Then compose all the isomorphisms. */
   bool, perm_to_pc := IsIsomorphic(perm_group, pc_group);
   pc_to_G := pc_to_fp * fp_to_G;
   iso := perm_to_pc * pc_to_G;

   G_to_pc := Inverse(pc_to_G);
   return iso, G, G_to_pc;
end function;


/* *************************************
Function compute_rec_data

Input: sign          signature
       small_group   group as returned by SmallGroup

Outcome: call RepEpi and return data computed using the resulting records.
**************************************** */
compute_rec_data := function(sign, small_group)
   tuple := IdentifyGroup(small_group);
   order := tuple[1];
   counter := tuple[2];
   group_label := Sprintf("%o.%o", order, counter);

   /* Check if the group is in the groups db */
   try
      group_data := gps_db[group_label];
   catch e
      PrintFile(logfile, Sprintf("%o is not in the groups db, so skip it\n", 
                                 group_label));
      return 0,0,0,0,0,0,0,0,0;
   end try;

   /* Compute data differently depending on whether the group is solvable or
      nonsolvable */
   if IsSolvable(small_group) then

      /* Get the PC group decoded from the pc_code */
      pc_code := group_data[1];
      try
         pc_group := SmallGroupDecoding(pc_code, order);
      catch e
         PrintFile(logfile, Sprintf("Error decoding pc_code for %o, " cat
                                    "so skip it\n", group_label));
         return 0,0,0,0,0,0,0,0,0;
      end try;

      /* Check that ngens matches the number of generators in pc_group */
      ngens := group_data[2];
      if ngens ne NumberOfGenerators(pc_group) then
         PrintFile(logfile, Sprintf("Number of generators in PC group of " cat
                                    "%o does not match ngens in groups " cat
                                    "db, so skip it\n", group_label));
         return 0,0,0,0,0,0,0,0,0;
      end if;

      /* Check if the group is in the transitive groups db. If not,
         log this group since a transitive group is not going to be passed 
         into RepiEpi */
      in_trans_db := true;
      try
         trans_data := gps_trans_db[group_label];
      catch e
         PrintFile(logfile, Sprintf("%o is solvable but not in the " cat
                                    "transitive groups db, so a PermRep " cat
                                    "group is passed into RepiEpi instead\n", 
                                    group_label));
         in_trans_db := false;
      end try;

      /* Decide whether to pass a group from the trans db or a PermRep group
         into RepEpi */
      use_trans_group := not IsAbelian(small_group) or order le max_ab_order;
      if in_trans_db and use_trans_group then
         trans_gp_label := trans_data[1];
         degree := trans_data[2];
         perm_gens := trans_data[3];
         group_str := Sprintf("PermutationGroup<%o|%o>", degree, perm_gens);
         perm_group := eval group_str;
      else 
         trans_gp_label := "N/A";
         group_str := Sprintf("PermRep(SmallGroup(%o,%o))", order, counter);
         perm_group := PermRep(small_group);
      end if;

      /* Call compute_iso and RepEpi */
      gens_used := group_data[3];
      iso, G, G_to_pc := compute_iso(perm_group, pc_group, gens_used);
      recs := RepresentativesEpimorphisms(sign, perm_group);

      /* Compute data with recs and return the data */
      recs, Cons, Cons_label := sort_recs_by_cc_label(recs, small_group);
      cc_labels, Lgenvects, connected_Lgenvects := 
         get_rec_data_s(recs, iso, G, G_to_pc);
      braids, topos := FindOrbits(perm_group, sign, Lgenvects, 
                                  cc_labels, sign[1]);
      return group_str, trans_gp_label, Cons, Cons_label, cc_labels, 
             Lgenvects, connected_Lgenvects, braids, topos;
   else
      /* Check if we can use perm_gens */
      perm_gens := group_data[5];
      if Type(perm_gens) eq MonStgElt and perm_gens eq "error" then 
         PrintFile(logfile, Sprintf("perm_gens not available for %o, " cat
                                    "so skip it\n", group_label));
         return 0,0,0,0,0,0,0,0,0;
      end if;

      /* Since a transitive group is not going to be passed into RepiEpi,
         log this group */
      PrintFile(logfile, Sprintf("%o is nonsolvable, so the perm group " cat
                                 "from the groups page is passed into " cat
                                 "RepEpi\n", group_label));
      /* Construct group from the groups page and pass it into RepEpi */
      degree := group_data[4];
      group_str := Sprintf("PermutationGroup<%o|%o>", degree, perm_gens);
      perm_group := eval group_str;
      recs := RepresentativesEpimorphisms(sign, perm_group);

      /* Compute data with recs */
      recs, Cons, Cons_label := sort_recs_by_cc_label(recs, small_group);
      cc_labels, Lgenvects, rewritten_Lgenvects := get_rec_data_ns(recs);
      /* Pass Lgenvects into FindOrbits rather than rewritten_Lgenvects
         because the former contains lists of GrpPermElts rather than 
         strings */
      braids, topos := FindOrbits(perm_group, sign, Lgenvects, 
                                  cc_labels, sign[1]);
      /* rewritten_Lgenvects is returned for the sixth return value rather 
         than Lgenvects because the former involves permutation strings 
         that are rearranged by their cycle type */
      /* rewritten_Lgenvects is returned for the seventh return value because
         it is already connected to the groups page */
      return group_str, "N/A", Cons, Cons_label, cc_labels, 
             rewritten_Lgenvects, rewritten_Lgenvects, braids, topos;
   end if; 
end function;
